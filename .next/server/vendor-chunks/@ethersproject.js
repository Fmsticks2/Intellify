"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject";
exports.ids = ["vendor-chunks/@ethersproject"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bytes/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2ludGVsbGlmeS13YXZlMi8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzP2VhYWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJ5dGVzLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   hexConcat: () => (/* binding */ hexConcat),\n/* harmony export */   hexDataLength: () => (/* binding */ hexDataLength),\n/* harmony export */   hexDataSlice: () => (/* binding */ hexDataSlice),\n/* harmony export */   hexStripZeros: () => (/* binding */ hexStripZeros),\n/* harmony export */   hexValue: () => (/* binding */ hexValue),\n/* harmony export */   hexZeroPad: () => (/* binding */ hexZeroPad),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   joinSignature: () => (/* binding */ joinSignature),\n/* harmony export */   splitSignature: () => (/* binding */ splitSignature),\n/* harmony export */   stripZeros: () => (/* binding */ stripZeros),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNrQztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ludGVsbGlmeS13YXZlMi8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL2luZGV4LmpzPzY0OWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUudG9IZXhTdHJpbmcpO1xufVxuZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBhcnJheS5zbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA9PSB2YWx1ZSAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpIHx8IHZhbHVlLmxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIodikgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuICAgIGNvbnN0IG9iamVjdHMgPSBpdGVtcy5tYXAoaXRlbSA9PiBhcnJheWlmeShpdGVtKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqZWN0cy5yZWR1Y2UoKGFjY3VtLCBpdGVtKSA9PiAoYWNjdW0gKyBpdGVtLmxlbmd0aCksIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgb2JqZWN0cy5yZWR1Y2UoKG9mZnNldCwgb2JqZWN0KSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgb2JqZWN0Lmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcbiAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDB4Zl0gKyBoZXg7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIweDBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qXG5mdW5jdGlvbiB1bm9kZGlmeSh2YWx1ZTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlcik6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIge1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhU2xpY2UoZGF0YSwgb2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG4gICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQsIDIgKyAyICogZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcbiAgICBpZiAodHJpbW1lZCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbW1lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHI6IFwiMHhcIixcbiAgICAgICAgczogXCIweFwiLFxuICAgICAgICBfdnM6IFwiMHhcIixcbiAgICAgICAgcmVjb3ZlcnlQYXJhbTogMCxcbiAgICAgICAgdjogMCxcbiAgICAgICAgeVBhcml0eUFuZFM6IFwiMHhcIixcbiAgICAgICAgY29tcGFjdDogXCIweFwiXG4gICAgfTtcbiAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeShzaWduYXR1cmUpO1xuICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIC8vIEVJUC0yMDk4OyBwdWxsIHRoZSB2IGZyb20gdGhlIHRvcCBiaXQgb2YgcyBhbmQgY2xlYXIgaXRcbiAgICAgICAgICAgIHJlc3VsdC52ID0gMjcgKyAoYnl0ZXNbMzJdID4+IDcpO1xuICAgICAgICAgICAgYnl0ZXNbMzJdICY9IDB4N2Y7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgIHJlc3VsdC52ID0gYnl0ZXNbNjRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZ1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuciA9IHNpZ25hdHVyZS5yO1xuICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcbiAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgLy8gYW5kIHZlcmlmeSBub24tbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9ICgodnNbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSB2IG1pc21hdGNoIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWNpZCBhbmQgdiB0byBwb3B1bGF0ZSBlYWNoIG90aGVyXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXJyYXlpZnkocmVzdWx0LnMpO1xuICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gX3ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC55UGFyaXR5QW5kUyA9IHJlc3VsdC5fdnM7XG4gICAgcmVzdWx0LmNvbXBhY3QgPSByZXN1bHQuciArIHJlc3VsdC55UGFyaXR5QW5kUy5zdWJzdHJpbmcoMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgc2lnbmF0dXJlLnIsXG4gICAgICAgIHNpZ25hdHVyZS5zLFxuICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuICAgIF0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\n\nfunction keccak256(data) {\n    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2M7QUFDcUI7QUFDekM7QUFDUCxrQkFBa0IseURBQWUsQ0FBQyw4REFBUTtBQUMxQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW50ZWxsaWZ5LXdhdmUyLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzPzJjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgc2hhMyBmcm9tIFwianMtc2hhM1wiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoZGF0YSkge1xuICAgIHJldHVybiAnMHgnICsgc2hhMy5rZWNjYWtfMjU2KGFycmF5aWZ5KGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"logger/5.8.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnRlbGxpZnktd2F2ZTIvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanM/Mjk3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwibG9nZ2VyLzUuOC4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js\");\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQ3RCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLEtBQUs7QUFDekMsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx5REFBeUQscUNBQXFDO0FBQ3pNO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZDQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW50ZWxsaWZ5LXdhdmUyLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzPzQzZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEludGVyYWN0aW9uIEVycm9yc1xuICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBhY3Rpb24sIHN1Y2ggYXMgc2lnbmluZyBhIG1lc3NhZ2Ugb3Igc2VuZGluZ1xuICAgIC8vIGEgdHJhbnNhY3Rpb25cbiAgICBFcnJvckNvZGVbXCJBQ1RJT05fUkVKRUNURURcIl0gPSBcIkFDVElPTl9SRUpFQ1RFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuO1xuY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2NlbnNvckVycm9ycyA9ICEhY2Vuc29yc2hpcDtcbiAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgfVxufVxuTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\n");

/***/ })

};
;